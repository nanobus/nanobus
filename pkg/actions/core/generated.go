// Code generated by @apexlang/codegen. DO NOT EDIT.

package core

import (
	"encoding/json"
	"fmt"

	"github.com/nanobus/nanobus/pkg/actions"
	"github.com/nanobus/nanobus/pkg/expr"
	"github.com/nanobus/nanobus/pkg/handler"
	"github.com/nanobus/nanobus/pkg/runtime"
)

// Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus a tellus nec
// metus tempus volutpat nec non velit. Nulla feugiat cursus dui, eu consequat enim
// vestibulum in. Mauris pulvinar posuere interdum. Vivamus pharetra elementum
// lobortis. Morbi blandit aliquam nisi. In in molestie quam. Interdum et malesuada
// fames ac ante ipsum primis in faucibus. Nullam vulputate congue viverra.
// Pellentesque consequat nisi ut ante blandit, nec congue ex tincidunt.
// Suspendisse ac sem vel velit aliquam bibendum. Phasellus nec mi vitae nulla
// ultrices maximus a sit amet ipsum.
type AuthorizeConfig struct {
	// Condition is the predicate expression for authorization.
	Condition *expr.ValueExpr        `json:"condition,omitempty" yaml:"condition,omitempty" msgpack:"condition,omitempty" mapstructure:"condition"`
	Has       []string               `json:"has,omitempty" yaml:"has,omitempty" msgpack:"has,omitempty" mapstructure:"has" validate:"dive"`
	Check     map[string]interface{} `json:"check,omitempty" yaml:"check,omitempty" msgpack:"check,omitempty" mapstructure:"check" validate:"dive"`
	Error     string                 `json:"error" yaml:"error" msgpack:"error" mapstructure:"error" validate:"required"`
}

func Authorize() (string, actions.Loader) {
	return "authorize", AuthorizeLoader
}

// TODO
type CallInterfaceConfig struct {
	Handler handler.Handler `json:"handler" yaml:"handler" msgpack:"handler" mapstructure:"handler" validate:"required"`
	Input   *expr.DataExpr  `json:"input,omitempty" yaml:"input,omitempty" msgpack:"input,omitempty" mapstructure:"input"`
}

func CallInterface() (string, actions.Loader) {
	return "call_interface", CallInterfaceLoader
}

// TODO
type CallProviderConfig struct {
	Handler handler.Handler `json:"handler" yaml:"handler" msgpack:"handler" mapstructure:"handler" validate:"required"`
	Input   *expr.DataExpr  `json:"input,omitempty" yaml:"input,omitempty" msgpack:"input,omitempty" mapstructure:"input"`
}

func CallProvider() (string, actions.Loader) {
	return "call_provider", CallProviderLoader
}

// TODO
type DecodeConfig struct {
	TypeField string `json:"typeField" yaml:"typeField" msgpack:"typeField" mapstructure:"typeField" validate:"required"`
	DataField string `json:"dataField" yaml:"dataField" msgpack:"dataField" mapstructure:"dataField" validate:"required"`
	// Codec is the name of the codec to use for decoding.
	Codec string `json:"codec" yaml:"codec" msgpack:"codec" mapstructure:"codec" validate:"required"`
	// codecArgs are the arguments to pass to the decode function.
	CodecArgs []interface{} `json:"codecArgs,omitempty" yaml:"codecArgs,omitempty" msgpack:"codecArgs,omitempty" mapstructure:"codecArgs" validate:"dive"`
}

func Decode() (string, actions.Loader) {
	return "decode", DecodeLoader
}

// TODO
type ExprConfig struct {
	Value *expr.ValueExpr `json:"value,omitempty" yaml:"value,omitempty" msgpack:"value,omitempty" mapstructure:"value" validate:"required_without=Data"`
	Data  *expr.DataExpr  `json:"data,omitempty" yaml:"data,omitempty" msgpack:"data,omitempty" mapstructure:"data" validate:"required_without=Value"`
	To    *string         `json:"to,omitempty" yaml:"to,omitempty" msgpack:"to,omitempty" mapstructure:"to"`
}

func Expr() (string, actions.Loader) {
	return "expr", ExprLoader
}

// TODO
type FilterConfig struct {
	// Condition is the predicate expression for filtering.
	Condition *expr.ValueExpr `json:"condition" yaml:"condition" msgpack:"condition" mapstructure:"condition" validate:"required"`
}

func Filter() (string, actions.Loader) {
	return "filter", FilterLoader
}

// TODO
type HTTPResponseConfig struct {
	Status  *uint32              `json:"status,omitempty" yaml:"status,omitempty" msgpack:"status,omitempty" mapstructure:"status"`
	Headers []HTTPResponseHeader `json:"headers,omitempty" yaml:"headers,omitempty" msgpack:"headers,omitempty" mapstructure:"headers" validate:"dive"`
}

func HTTPResponse() (string, actions.Loader) {
	return "http_response", HTTPResponseLoader
}

// TODO
type HTTPResponseHeader struct {
	Name  string          `json:"name" yaml:"name" msgpack:"name" mapstructure:"name" validate:"required"`
	Value *expr.ValueExpr `json:"value" yaml:"value" msgpack:"value" mapstructure:"value" validate:"required"`
}

// TODO
type HTTPConfig struct {
	// URL is HTTP URL to request.
	URL string `json:"url" yaml:"url" msgpack:"url" mapstructure:"url" validate:"required"`
	// Method is the HTTP method.
	Method string `json:"method" yaml:"method" msgpack:"method" mapstructure:"method" validate:"required"`
	// Body is the data to sent as the body payload.
	Body *expr.DataExpr `json:"body,omitempty" yaml:"body,omitempty" msgpack:"body,omitempty" mapstructure:"body"`
	// Metadata is the input binding metadata.
	Headers *expr.DataExpr `json:"headers,omitempty" yaml:"headers,omitempty" msgpack:"headers,omitempty" mapstructure:"headers"`
	// Output is an optional transformation to be applied to the response.
	Output *expr.DataExpr `json:"output,omitempty" yaml:"output,omitempty" msgpack:"output,omitempty" mapstructure:"output"`
	// Codec is the name of the codec to use for decoing.
	Codec string `json:"codec" yaml:"codec" msgpack:"codec" mapstructure:"codec" validate:"required"`
	// Args are the arguments to pass to the decode function.
	CodecArgs []interface{} `json:"codecArgs,omitempty" yaml:"codecArgs,omitempty" msgpack:"codecArgs,omitempty" mapstructure:"codecArgs" validate:"dive"`
}

func HTTP() (string, actions.Loader) {
	return "http", HTTPLoader
}

// TODO
type InvokeConfig struct {
	// Name of the handler to invoke.
	Handler *handler.Handler `json:"handler,omitempty" yaml:"handler,omitempty" msgpack:"handler,omitempty" mapstructure:"handler"`
	// Input optionally transforms the input sent to the function.
	Input *expr.DataExpr `json:"input,omitempty" yaml:"input,omitempty" msgpack:"input,omitempty" mapstructure:"input"`
}

func Invoke() (string, actions.Loader) {
	return "invoke", InvokeLoader
}

// TODO
type JMESPathConfig struct {
	// Path is the predicate expression for filtering.
	Path string `json:"path" yaml:"path" msgpack:"path" mapstructure:"path" validate:"required"`
	// Data is the optional data expression to pass to jq.
	Data *expr.DataExpr `json:"data,omitempty" yaml:"data,omitempty" msgpack:"data,omitempty" mapstructure:"data"`
	// Var, if set, is the variable that is set with the result.
	Var *string `json:"var,omitempty" yaml:"var,omitempty" msgpack:"var,omitempty" mapstructure:"var"`
}

func JMESPath() (string, actions.Loader) {
	return "jmespath", JMESPathLoader
}

// TODO
type JQConfig struct {
	// Query is the predicate expression for filtering.
	Query string `json:"query" yaml:"query" msgpack:"query" mapstructure:"query" validate:"required"`
	// Data is the optional data expression to pass to jq.
	Data *expr.DataExpr `json:"data,omitempty" yaml:"data,omitempty" msgpack:"data,omitempty" mapstructure:"data"`
	// Single, if true, returns the first result.
	Single bool `json:"single" yaml:"single" msgpack:"single" mapstructure:"single"`
	// Var, if set, is the variable that is set with the result.
	Var *string `json:"var,omitempty" yaml:"var,omitempty" msgpack:"var,omitempty" mapstructure:"var"`
}

func JQ() (string, actions.Loader) {
	return "jq", JQLoader
}

// TODO
type LogConfig struct {
	Format string `json:"format" yaml:"format" msgpack:"format" mapstructure:"format" validate:"required"`
	// Args are the evaluations to use as arguments into the string format.
	Args []*expr.ValueExpr `json:"args,omitempty" yaml:"args,omitempty" msgpack:"args,omitempty" mapstructure:"args" validate:"dive"`
}

func Log() (string, actions.Loader) {
	return "log", LogLoader
}

// TODO
type ReCaptchaConfig struct {
	SiteVerifyURL string          `json:"siteVerifyUrl" yaml:"siteVerifyUrl" msgpack:"siteVerifyUrl" mapstructure:"siteVerifyUrl" validate:"required"`
	Secret        string          `json:"secret" yaml:"secret" msgpack:"secret" mapstructure:"secret" validate:"required"`
	Response      *expr.ValueExpr `json:"response" yaml:"response" msgpack:"response" mapstructure:"response" validate:"required"`
	Score         float64         `json:"score" yaml:"score" msgpack:"score" mapstructure:"score"`
	Action        *string         `json:"action,omitempty" yaml:"action,omitempty" msgpack:"action,omitempty" mapstructure:"action"`
}

func ReCaptcha() (string, actions.Loader) {
	return "recaptcha", ReCaptchaLoader
}

// TODO
type RouteConfig struct {
	// Selection defines the selection mode: single or multi.
	Selection SelectionMode `json:"selection" yaml:"selection" msgpack:"selection" mapstructure:"selection"`
	// Routes are the possible runnable routes which conditions for selection.
	Routes []RouteCondition `json:"routes" yaml:"routes" msgpack:"routes" mapstructure:"routes" validate:"dive"`
}

func Route() (string, actions.Loader) {
	return "route", RouteLoader
}

// TODO
type RouteCondition struct {
	// Name if the overall summary of this route.
	Name string `json:"name" yaml:"name" msgpack:"name" mapstructure:"name" validate:"required"`
	// When is the predicate expression for filtering.
	When *expr.ValueExpr `json:"when" yaml:"when" msgpack:"when" mapstructure:"when" validate:"required"`
	// Then is the steps to process.
	Then []runtime.Step `json:"then" yaml:"then" msgpack:"then" mapstructure:"then" validate:"dive"`
}

// SelectionMode indicates how many routes can be selected.
type SelectionMode int32

const (
	SelectionModeSingle SelectionMode = 1
	SelectionModeMulti  SelectionMode = 2
)

var toStringSelectionMode = map[SelectionMode]string{
	SelectionModeSingle: "single",
	SelectionModeMulti:  "multi",
}

var toIDSelectionMode = map[string]SelectionMode{
	"single": SelectionModeSingle,
	"multi":  SelectionModeMulti,
}

func (e SelectionMode) String() string {
	str, ok := toStringSelectionMode[e]
	if !ok {
		return "unknown"
	}
	return str
}

func (e *SelectionMode) FromString(str string) error {
	var ok bool
	*e, ok = toIDSelectionMode[str]
	if !ok {
		return fmt.Errorf("unknown value %q for SelectionMode", str)
	}
	return nil
}

// MarshalJSON marshals the enum as a quoted json string
func (e SelectionMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON unmashals a quoted json string to the enum value
func (e *SelectionMode) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err != nil {
		return err
	}
	return e.FromString(str)
}
