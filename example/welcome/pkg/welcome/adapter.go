// Code generated by @nanobus/codegen. DO NOT EDIT.

package welcome

import (
	"context"
	"errors"

	"github.com/nanobus/adapter-go/adapter"
	"github.com/nanobus/adapter-go/adapter/rsocket"
	"github.com/nanobus/adapter-go/codec/msgpack"
	"github.com/nanobus/adapter-go/metadata"
)

type App struct {
	ctx context.Context
	a   adapter.Adapter
}

func NewApp(ctx context.Context) *App {
	return &App{
		ctx: ctx,
		a:   rsocket.New(msgpack.New()),
	}
}

func (a *App) Start() error {
	err := a.a.Start(a.ctx)
	if errors.Is(err, context.Canceled) {
		err = nil
	}
	return err
}

func (a *App) RegisterInbound(handlers Inbound) {
	a.a.RegisterRR("/welcome.v1.Inbound/greetCustomer", a.inbound_greetCustomerWrapper(handlers.GreetCustomer))
}

func (a *App) inbound_greetCustomerWrapper(handler func(ctx context.Context, customer *Customer) error) adapter.RequestResponseHandler {
	return func(ctx context.Context, md metadata.MD, data []byte, sink adapter.MonoSink) {
		ctx = metadata.NewIncomingContext(ctx, md)
		var input Customer
		a.a.HandleRR(data, sink, &input, func() (interface{}, error) {
			err := handler(ctx, &input)
			return nil, err
		})
	}
}

func (a *App) NewOutbound() Outbound {
	return NewOutboundProvider(a.a)
}

type OutboundProvider struct {
	a adapter.Adapter
}

func NewOutboundProvider(a adapter.Adapter) *OutboundProvider {
	return &OutboundProvider{
		a: a,
	}
}

func (m *OutboundProvider) SendEmail(ctx context.Context, email string, message string) error {
	inputArgs := outboundSendEmailArgs{
		Email:   email,
		Message: message,
	}
	return m.a.InvokeFF(ctx, "/welcome.v1.Outbound/sendEmail", inputArgs)
}

type outboundSendEmailArgs struct {
	Email   string `json:"email" msgpack:"email"`
	Message string `json:"message" msgpack:"message"`
}
